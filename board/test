# utils/path_utils.py
import os
import sys
from pathlib import Path

def resolve_project_root():
    """
    Get project root path that works in all contexts:
    1. Running .py files directly from utils/services
    2. Running notebooks from notebooks/
    3. Importing between modules
    """
    try:
        # First try getting notebook path (for notebook context)
        notebook_path = dbutils.notebook.entry_point.getDbutils().notebook().getPath().get()
        workspace_dir = Path(notebook_path).parent
        return workspace_dir.parent
    except:
        # If not in notebook context, resolve from file location
        current_file = Path(os.path.abspath(__file__))
        current_dir = current_file.parent
        
        # If in utils or services, go up one level
        if current_dir.name in ['utils', 'services']:
            return current_dir.parent
            
        # Otherwise traverse up until finding project root markers
        while current_dir.name:
            if all(os.path.exists(os.path.join(str(current_dir), d)) 
                  for d in ['utils', 'notebooks', 'services']):
                return current_dir
            current_dir = current_dir.parent
            
        raise RuntimeError("Could not find project root directory")

def setup_project_path():
    """Setup Python path and return project root"""
    project_root = resolve_project_root()
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))
    return project_root

def get_dbfs_path(path):
    """Convert any path to DBFS path"""
    path_str = str(path)
    if not path_str.startswith('/dbfs/'):
        return f"/dbfs{path_str}"
    return path_str

# Example of using in a service (services/file_tagger.py)
import os
import sys
from pathlib import Path

# First handle paths - this works when run directly or imported
current_file = Path(os.path.abspath(__file__))
current_dir = current_file.parent

# Get project root
if current_dir.name == 'services':
    project_root = current_dir.parent
else:
    project_root = current_dir
    while not all(os.path.exists(os.path.join(str(project_root), d)) 
                 for d in ['utils', 'notebooks', 'services']):
        project_root = project_root.parent

# Add to path before imports
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Now safe to import
from utils import file_utils

def tag_file(file_path, tag):
    """Tag a file with metadata."""
    content = file_utils.read_file_content(file_path)
    return f"{tag}: {content}"

# Example of using in a notebook (notebooks/bronze_full_ingestion.ipynb)
# First cell:
import os
import sys
from pathlib import Path

# First handle paths
try:
    # Try notebook context
    notebook_path = dbutils.notebook.entry_point.getDbutils().notebook().getPath().get()
    workspace_dir = Path(notebook_path).parent
    project_root = workspace_dir.parent
except:
    # Fallback to file location
    current_file = Path(os.path.abspath(__file__))
    project_root = current_file.parent.parent

# Add to path before imports
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Now safe to import
from utils import file_utils, git_utils
from services import file_tagger

# Example of using in a utility (utils/file_utils.py)
import os
import sys
import json
from pathlib import Path

# First handle paths
current_file = Path(os.path.abspath(__file__))
current_dir = current_file.parent

# Get project root
if current_dir.name == 'utils':
    project_root = current_dir.parent
else:
    project_root = current_dir
    while not all(os.path.exists(os.path.join(str(project_root), d)) 
                 for d in ['utils', 'notebooks', 'services']):
        project_root = project_root.parent

# Add to path before imports
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

def read_json_config(config_name):
    """Read JSON config file from configs directory."""
    try:
        config_path = f"/dbfs{str(project_root / 'configs' / config_name)}"
        with open(config_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error reading config {config_name}: {e}")
        return {}
