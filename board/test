# Project Structure:
# project_root/
# ├── utils/
# │   ├── __init__.py
# │   ├── path_utils.py
# │   ├── file_utils.py
# │   └── git_utils.py
# ├── services/
# │   ├── __init__.py
# │   ├── file_tagger.py
# │   └── metadata_service.py
# ├── configs/
# │   └── bronze_config.json
# ├── bronze_etl.ipynb
# ├── silver_etl.ipynb
# └── README.md

###############################################
# utils/path_utils.py
###############################################
import os
import sys
from pathlib import Path
from typing import Optional


class ProjectPathManager:
    _instance: Optional['ProjectPathManager'] = None
    _is_initialized = False

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not self._is_initialized:
            self.project_root = self._resolve_project_root()
            self._setup_paths()
            ProjectPathManager._is_initialized = True

    def _resolve_project_root(self) -> Path:
        """Get project root from any execution context"""
        try:
            # Try Databricks notebook context
            import dbutils.notebook
            notebook_path = dbutils.notebook.entry_point.getDbutils().notebook().getPath().get()
            return Path(notebook_path).parent
        except:
            # Use current working directory
            current_dir = Path(os.getcwd())
            
            # If in utils or services, go up one level
            if current_dir.name in ['utils', 'services']:
                current_dir = current_dir.parent
                
            return current_dir

    def _setup_paths(self):
        """Initialize paths and add to system path"""
        self.utils_dir = self.project_root / 'utils'
        self.services_dir = self.project_root / 'services'
        self.configs_dir = self.project_root / 'configs'

        # Add project root to Python path if not already there
        project_root_str = str(self.project_root)
        if project_root_str not in sys.path:
            sys.path.insert(0, project_root_str)

    def get_dbfs_path(self, path: Path | str) -> str:
        """Convert to DBFS path if needed"""
        path_str = str(path)
        return f"/dbfs{path_str}" if not path_str.startswith('/dbfs/') else path_str

    @property
    def paths(self) -> dict:
        """Get all project paths"""
        return {
            'project_root': self.project_root,
            'utils_dir': self.utils_dir,
            'services_dir': self.services_dir,
            'configs_dir': self.configs_dir
        }


# Create global instance
project_paths = ProjectPathManager()

if __name__ == '__main__':
    print("\nProject Paths:")
    for name, path in project_paths.paths.items():
        print(f"{name}: {path}")

###############################################
# utils/__init__.py
###############################################
from utils.path_utils import project_paths
from utils import file_utils
from utils import git_utils

paths = project_paths  # Make paths available at package level

###############################################
# services/__init__.py
###############################################
from utils.path_utils import project_paths
from services import file_tagger
from services import metadata_service

###############################################
# utils/file_utils.py
###############################################
import json
from pathlib import Path
from typing import Dict, Any
from utils.path_utils import project_paths


def read_json_config(config_name: str) -> Dict[str, Any]:
    """Read JSON configuration file"""
    try:
        config_path = project_paths.configs_dir / config_name
        with open(config_path, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error reading config {config_name}: {e}")
        return {}


if __name__ == '__main__':
    config = read_json_config('bronze_config.json')
    print("\nConfig contents:", config)

###############################################
# services/file_tagger.py
###############################################
from utils.path_utils import project_paths
from utils import file_utils


def tag_file(file_path: str, tag: str) -> str:
    """Add a tag to file content"""
    try:
        full_path = project_paths.project_root / file_path
        with open(full_path, 'r') as f:
            content = f.read()
        return f"{tag}: {content}"
    except Exception as e:
        print(f"Error tagging file {file_path}: {e}")
        return ""


if __name__ == '__main__':
    test_file = 'README.md'
    result = tag_file(test_file, "TEST")
    print(f"\nTagged content for {test_file}:")
    print(result)

###############################################
# bronze_etl.ipynb
###############################################
# First cell:
from utils.path_utils import project_paths
from utils import file_utils
from services import file_tagger

# Verify paths
print("Project paths:")
for name, path in project_paths.paths.items():
    print(f"{name}: {path}")

# Use utilities
config = file_utils.read_json_config('bronze_config.json')
tagged_content = file_tagger.tag_file('example.txt', "bronze")
